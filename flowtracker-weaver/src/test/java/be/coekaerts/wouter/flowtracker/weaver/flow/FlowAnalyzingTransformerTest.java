package be.coekaerts.wouter.flowtracker.weaver.flow;

import static org.junit.Assert.assertEquals;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import org.junit.Test;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.util.CheckClassAdapter;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceMethodVisitor;

/**
 * Tests for FlowAnalyzingTransformer by inspecting generated bytecode.
 * flowtracker mostly tests FlowAnalyzingTransformer indirectly, by executing instrumented code, but
 * this test class is an exception to that: testing if the bytecode looks as expected.
 */
public class FlowAnalyzingTransformerTest {

  @Test
  public void testArraycopy() {
    testTransform(new Object() {
                    void t(byte[] bytes1, byte[] bytes2) {
                      System.arraycopy(bytes1, 1, bytes2, 2, 3);
                    }
                  },
        "ALOAD 1\n"
            + "ICONST_1\n"
            + "ALOAD 2\n"
            + "ICONST_2\n"
            + "ICONST_3\n"
            + "INVOKESTATIC java/lang/System.arraycopy (Ljava/lang/Object;ILjava/lang/Object;II)V\n"
            + "RETURN\n"
            + "MAXSTACK = 5\n"
            + "MAXLOCALS = 3\n",
        "ALOAD 1\n"
            + "ICONST_1\n"
            + "ALOAD 2\n"
            + "ICONST_2\n"
            + "ICONST_3\n"
            + "INVOKESTATIC be/coekaerts/wouter/flowtracker/hook/SystemHook.arraycopy (Ljava/lang/Object;ILjava/lang/Object;II)V\n"
            + "RETURN\n"
            + "MAXSTACK = 5\n"
            + "MAXLOCALS = 3\n");
  }

  /**
   * Test insertion of code to get tracker and pass it to a hook, using the simple example of an
   * array load and store
   */
  @Test
  public void testTracker() {
    testTransform(new Object() {
                    void t(byte[] bytes1, byte[] bytes2) {
                      bytes1[1] = bytes2[2];
                    }
                  },
        "ALOAD 1\n"
            + "ICONST_1\n"
            + "ALOAD 2\n"
            + "ICONST_2\n"
            + "BALOAD\n"
            + "BASTORE\n"
            + "RETURN\n"
            + "MAXSTACK = 4\n"
            + "MAXLOCALS = 3\n",
        "ALOAD 1\n"
            + "ICONST_1\n"
            + "ALOAD 2\n"
            + "ICONST_2\n"
            // from ArrayLoadValue.insertTrackStatements
            + "ISTORE 4\n"
            + "ASTORE 3\n"
            + "ALOAD 3\n"
            + "ILOAD 4\n"
            // ...
            + "BALOAD\n"
            // from ArrayStore.insertTrackStatements
            //   from ArrayLoadValue.loadSourceTracker
            + "ALOAD 3\n"
            + "INVOKESTATIC be/coekaerts/wouter/flowtracker/tracker/TrackerRepository.getTracker (Ljava/lang/Object;)Lbe/coekaerts/wouter/flowtracker/tracker/Tracker;\n"
            //   from ArrayLoadValue.loadSourceIndex
            + "ILOAD 4\n"
            + "INVOKESTATIC be/coekaerts/wouter/flowtracker/hook/ArrayHook.setByte ([BIBLbe/coekaerts/wouter/flowtracker/tracker/Tracker;I)V\n"
            // ...
            + "RETURN\n"
            + "MAXSTACK = 6\n"
            + "MAXLOCALS = 5\n");
  }

  /**
   * Given an object of a class that contains one method, tests if the code before and after
   * transformation are as expected;
   */
  static void testTransform(Object o, String expectOriginalCode, String expectedTransformedCode) {
    MethodPrintingClassVisitor afterVisitor =
        new MethodPrintingClassVisitor(new CheckClassAdapter(null));
    ClassVisitor transformingVisitor =
        new FlowAnalyzingTransformer().createClassAdapter(afterVisitor);
    MethodPrintingClassVisitor beforeVisitor =
        new MethodPrintingClassVisitor(transformingVisitor);

    try {
      new ClassReader(o.getClass().getName()).accept(beforeVisitor, ClassReader.SKIP_DEBUG);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }

    assertEquals(expectOriginalCode, beforeVisitor.getCode());
    assertEquals(expectedTransformedCode, afterVisitor.getCode());
  }

  /**
   * ClassVisitor that only sends the implementation of a method (not the rest of the class content)
   * to a Textifier.
   */
  private static class MethodPrintingClassVisitor extends ClassVisitor {

    final Textifier textifier = new Textifier();

    public MethodPrintingClassVisitor(ClassVisitor cv) {
      super(Opcodes.ASM9, cv);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String desc, String signature,
        String[] exceptions) {
      // skip the constructor, that's not the method we're interested in
      if (name.equals("<init>")) {
        return null;
      }

      MethodVisitor mv = cv.visitMethod(access, name, desc, signature, exceptions);
      return new TraceMethodVisitor(mv, textifier);
    }

    String getCode() {
      StringWriter sw = new StringWriter();
      textifier.print(new PrintWriter(sw));
      // remove indentation that's added by asm, but is only useful if the method implementation is
      // printed in the context of a whole class
      return sw.toString().substring(4).replace("\n    ", "\n");
    }
  }
}